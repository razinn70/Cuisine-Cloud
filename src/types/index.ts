import { Timestamp } from 'firebase/firestore';
import { z } from 'zod';

// =================================================================
// ENUMS & CONSTANTS
// =================================================================

export enum RecipeDifficulty {
  Beginner = 'Beginner',
  Intermediate = 'Intermediate',
  Advanced = 'Advanced',
}

export enum CuisineType {
  Italian = 'Italian',
  Mexican = 'Mexican',
  Japanese = 'Japanese',
  Indian = 'Indian',
  French = 'French',
  Chinese = 'Chinese',
  Thai = 'Thai',
  Spanish = 'Spanish',
  American = 'American',
  Other = 'Other',
}

// =================================================================
// CORE DATA MODELS
// =================================================================

export const NutritionInfoSchema = z.object({
  calories: z.number().positive().optional(),
  protein: z.number().positive().optional(),
  carbs: z.number().positive().optional(),
  fat: z.number().positive().optional(),
  fiber: z.number().positive().optional(),
  sugar: z.number().positive().optional(),
  sodium: z.number().positive().optional(),
});
export type NutritionInfo = z.infer<typeof NutritionInfoSchema>;

export const IngredientSchema = z.object({
  id: z.string().uuid(),
  name: z.string().min(1, "Ingredient name cannot be empty."),
  quantity: z.number().positive("Quantity must be positive."),
  unit: z.string(),
});
export type Ingredient = z.infer<typeof IngredientSchema>;

export const RecipeSchema = z.object({
  id: z.string(),
  authorId: z.string(),
  title: z.string().min(3, "Title must be at least 3 characters."),
  description: z.string().min(10, "Description must be at least 10 characters."),
  difficulty: z.nativeEnum(RecipeDifficulty),
  cuisine: z.nativeEnum(CuisineType).optional(),
  prepTimeMinutes: z.number().int().positive("Preparation time must be a positive number."),
  cookTimeMinutes: z.number().int().positive("Cooking time must be a positive number."),
  servings: z.number().int().positive("Servings must be a positive number."),
  tags: z.array(z.string()).optional(),
  ingredients: z.array(IngredientSchema),
  instructions: z.array(z.string().min(1, "Instruction cannot be empty.")),
  nutrition: NutritionInfoSchema,
  imageUrl: z.string().url().optional(),
  createdAt: z.custom<Timestamp>((val) => val instanceof Timestamp, "Invalid Timestamp for createdAt"),
  updatedAt: z.custom<Timestamp>((val) => val instanceof Timestamp, "Invalid Timestamp for updatedAt"),
  rating: z.number().min(0).max(5).default(0),
});
export type Recipe = z.infer<typeof RecipeSchema>;


// This type is used for creating a recipe. It omits fields that are
// generated by the server or have default values.
export const CreateRecipeFormSchema = RecipeSchema.omit({
  id: true,
  authorId: true,
  createdAt: true,
  updatedAt: true,
  rating: true,
  imageUrl: true,
  // Nutrition is calculated on the backend/server-side
  nutrition: true, 
});
export type CreateRecipeFormData = z.infer<typeof CreateRecipeFormSchema>;

// This is the data that the repository layer expects.
export type CreateRecipeData = CreateRecipeFormData & {
  authorId: string;
  imageUrl: string;
  nutrition: NutritionInfo;
  rating?: number;
};


export const UserProfileSchema = z.object({
  uid: z.string(),
  displayName: z.string().optional(),
  email: z.string().email(),
  photoURL: z.string().url().optional(),
  dietaryRestrictions: z.array(z.string()).optional(),
  healthGoals: z.array(z.string()).optional(),
});
export type UserProfile = z.infer<typeof UserProfileSchema>;

// =================================================================
// ENRICHED & WRAPPER TYPES
// =================================================================

export const RecipeWithAuthorSchema = RecipeSchema.extend({
  author: UserProfileSchema.pick({
    uid: true,
    displayName: true,
    photoURL: true,
  }),
});
export type RecipeWithAuthor = z.infer<typeof RecipeWithAuthorSchema>;

export interface ApiResponse<T> {
  success: boolean;
  data: T | null;
  error?: {
    message: string;
    code?: number;
  };
}

// =================================================================
// AI & SERVICE-SPECIFIC TYPES
// =================================================================

export const AnalyzeRecipeInputSchema = z.object({
  title: z.string().describe("The title of the recipe."),
  ingredients: z.array(z.string()).describe("A list of ingredients with quantities."),
  instructions: z.array(z.string()).describe("The cooking instructions."),
});
export type AnalyzeRecipeInput = z.infer<typeof AnalyzeRecipeInputSchema>;


export interface AnalyticsEvent {
    id: string;
    name: string;
    data: { [key: string]: any };
    createdAt: Timestamp;
}

export const RecommendedRecipesSchema = z.object({
  recommendations: z.array(z.object({
    recipeId: z.string().describe("The ID of the recommended recipe."),
    reason: z.string().describe("A brief, user-facing explanation for why this recipe was recommended."),
  })).describe("A list of personalized recipe recommendations."),
});
export type RecommendedRecipes = z.infer<typeof RecommendedRecipesSchema>;

export const RecommendRecipesInputSchema = z.object({
  userId: z.string().describe("The ID of the user to generate recommendations for."),
  count: z.number().int().positive().optional().default(5).describe("The number of recommendations to generate."),
  candidateRecipes: z.array(z.object({
    id: z.string(),
    title: z.string(),
    description: z.string(),
  })).describe('A list of candidate recipes to choose from for recommendations.'),
});
export type RecommendRecipesInput = z.infer<typeof RecommendRecipesInputSchema>;

export const GeneratedRecipeSchema = z.object({
    title: z.string().describe("A creative and appealing title for the recipe."),
    description: z.string().describe("A short, enticing description of the dish."),
    cookTime: z.string().describe("Estimated total cooking time (e.g., '45 minutes')."),
    servings: z.string().describe("The number of servings the recipe makes (e.g., '4 servings')."),
    ingredients: z.array(z.object({
        name: z.string().describe("The name of the ingredient."),
        quantity: z.string().describe("The quantity of the ingredient (e.g., '1 cup', '2 tbsp')."),
    })).describe("A list of ingredients required for the recipe."),
    instructions: z.array(z.string()).describe("Step-by-step instructions for preparing the dish."),
    nutrition: NutritionInfoSchema.pick({calories:true, protein:true, carbs:true, fat:true}).extend({
        calories: z.string(),
        protein: z.string(),
        carbs: z.string(),
        fat: z.string()
    }).describe("Estimated nutritional information per serving."),
});
export type GeneratedRecipe = z.infer<typeof GeneratedRecipeSchema>;

export const GenerateRecipeInputSchema = z.object({
  ingredients: z.string().describe("A comma-separated list of ingredients the user has."),
  preferences: z.string().describe("User preferences for the recipe (e.g., 'quick and easy', 'healthy', 'vegetarian')."),
});
export type GenerateRecipeInput = z.infer<typeof GenerateRecipeInputSchema>;

const DayPlanSchema = z.object({
  Breakfast: z.string().optional().describe("The name of the recipe for breakfast."),
  Lunch: z.string().optional().describe("The name of the recipe for lunch."),
  Dinner: z.string().optional().describe("The name of the recipe for dinner."),
});

export const MealPlanSchema = z.object({
  plan: z.record(z.string(), DayPlanSchema).describe("The generated meal plan, with days of the week as keys containing recipe names."),
});
export type MealPlan = z.infer<typeof MealPlanSchema>;

export const GenerateMealPlanInputSchema = z.object({
  prompt: z.string().describe("The user's request for the meal plan (e.g., dietary needs, number of days)."),
  recipes: z.array(z.object({ title: z.string(), description: z.string() })).describe("A list of available recipes with their titles and descriptions."),
});
export type GenerateMealPlanInput = z.infer<typeof GenerateMealPlanInputSchema>;

export const ShoppingListCategorySchema = z.object({
    category: z.string().describe("The category of the shopping list items (e.g., Produce, Dairy, Meat, Pantry)."),
    items: z.array(z.string()).describe("A list of food items in this category, without quantities."),
});
export type ShoppingListCategory = z.infer<typeof ShoppingListCategorySchema>;

export const ShoppingListSchema = z.object({
  shoppingList: z.array(ShoppingListCategorySchema),
});
export type ShoppingList = z.infer<typeof ShoppingListSchema>;


export const GenerateShoppingListInputSchema = z.object({
  ingredients: z.array(z.string()).describe("A flat list of ingredients, including quantities. e.g., ['1 cup Flour', '2 eggs']"),
});
export type GenerateShoppingListInput = z.infer<typeof GenerateShoppingListInputSchema>;

export const GetIngredientsInputSchema = z.object({
  recipes: z.array(z.custom<Recipe>()).describe("A list of full recipe objects."),
});
export type GetIngredientsInput = z.infer<typeof GetIngredientsInputSchema>;

export const GetIngredientsOutputSchema = z.object({
  ingredients: z.array(z.string()).describe("A flat list of aggregated ingredients."),
});
export type GetIngredientsOutput = z.infer<typeof GetIngredientsOutputSchema>;

export const SmartRecipeToolInputSchema = z.object({
  recipe: z.string().optional().describe('The recipe to be modified, as text.'),
  fileDataUri: z.string().optional().describe("An image or document of a recipe, as a data URI that must include a MIME type and use Base64 encoding. Expected format: 'data:<mimetype>;base64,<encoded_data>'."),
  dietaryRestrictions: z.string().describe('The dietary restrictions to consider when modifying the recipe.'),
});
export type SmartRecipeToolInput = z.infer<typeof SmartRecipeToolInputSchema>;

export const SmartRecipeToolOutputSchema = z.object({
  modifiedRecipe: z.string().describe('The modified recipe with suggestions for substitutions or modifications.'),
});
export type SmartRecipeToolOutput = z.infer<typeof SmartRecipeToolOutputSchema>;
